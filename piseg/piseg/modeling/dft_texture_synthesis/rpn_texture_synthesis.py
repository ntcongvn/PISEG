#https://github.com/JasonPlawinski/TextureSynthesis
from PIL import Image
import numpy as np
import math
from random import randint
from scipy.ndimage.filters import laplace 
import scipy.stats as st
from scipy.signal import correlate2d
import collections
import cv2

def rgb2gray(rgb):
    r, g, b = rgb[:,:,0], rgb[:,:,1], rgb[:,:,2]
    gray = 0.2989 * r + 0.5870 * g + 0.1140 * b
    return gray

def P2R(radii, angles):
    '''Polar to cartesian'''
    return radii * np.exp(1j*angles)

def R2P(x):
    '''Cartesian to polar'''
    return np.abs(x), np.angle(x)

def LaplacianInterriorDomain(Image):
    '''Computes a tweak version of the laplacian. This version is similar to the classical 
    laplacian except for pixel around the bordure taking into account the lower number of neighbors
    in sides and corners'''
    M=len(Image)
    N=len(Image[0])
    u=np.copy(Image)
    #Applying the laplacian to the image
    DeltaU=laplace(u)
    v1=np.zeros([M,N])
    v2=np.zeros([M,N])
    #subtracting the values of neigboring pixels near the edges
    for y in range(N):
        v1[0,y]=u[M-1,y]-u[0,y]
        v1[M-1,y]=u[0,y]-u[M-1,y]
    for x in range(M):
        v2[x,0]=u[x,N-1]-u[x,0]
        v2[x,N-1]=u[x,0]-u[x,N-1]
    v=v1+v2
    DeltaU_V=DeltaU-v
    #Returning the Interrior laplacian
    return(DeltaU_V)

def AddNoise(Image,Noise):
    '''Add noise to the phase/argument of an image'''
    ImageFFT=(np.fft.fft2(Image))
    norm, phase = R2P(ImageFFT)
    NImageFFT=P2R(norm,phase+Noise)
    return((np.abs(np.fft.ifft2(NImageFFT))))

def GenerateNoise(Image):
    '''Generate Uniform noise between -pi and pi'''
    RandomPhase=np.random.rand(len(Image),len(Image[0]))*2*math.pi-np.ones([len(Image),len(Image[0])])*math.pi
    return RandomPhase

def RPN(Image):
    ''' This function generates a texture of the same size as the input.
    For RGB images the same noise is added to all the components to make sure 
    no new color is created'''
    Noise=GenerateNoise(Image)
    NewImage=np.zeros(Image.shape)
    NewImage[:,:,0]=AddNoise(Image[:,:,0],Noise)
    NewImage[:,:,1]=AddNoise(Image[:,:,1],Noise)
    NewImage[:,:,2]=AddNoise(Image[:,:,2],Noise)
    return(NewImage)

def PeriodicComponent(Image):
    '''Computing the Periodic component to get rid of edge artefact present
    in Fourrier's domain'''
    M=len(Image)
    N=len(Image[0])
    #Computing the laplacian of the Interrior domain
    Lap=LaplacianInterriorDomain(Image)
    LapFFT=np.fft.fft2(Lap)
    #Vectorized Poisson solver using the FT of the laplacian
    PFFT=np.zeros([M,N],dtype=complex)
    PFFT2=np.copy(LapFFT)
    cosi=np.tile(np.arange(0,M,dtype=float)*2*math.pi/M,[N,1])
    cosj=np.tile(np.arange(0,N,dtype=float)*2*math.pi/N,[M,1]).transpose()
    cosi[0,0]=1
    temp=2*np.cos(cosi)+2*np.cos(cosj)-np.ones([M,N])*4
    PFFT2=np.divide(PFFT2,temp)
    PFFT2[0,0]=np.sum(np.ravel(Image))
    #Iterative Poisson solver, easier to read but much slower
#     for i in range(M):
#         for j in range(N):
#             if (i==0 and j==0):
#                 PFFT[i,j]=np.sum(np.ravel(Image))
#             else:
#                 PFFT[i,j]=LapFFT[i,j]/(2*np.cos(2*i*math.pi/M)+2*np.cos(2*j*math.pi/N)-4)
    P=np.fft.ifft2(PFFT2)
    return(P)

def ExpandTexture(Image,S0,S1):
    '''To create a texture larger than the input the texture has to be generated by
    creating 1st a texture of the intial size and then expanding it
    The texture of the periodic component is placed at the center of the image and then the
    random noise is applied'''
    M=len(Image)
    N=len(Image[0])
    #Computing the mean of each channel the image to fill the generated image
    #before expanding the texture on it
    mR=np.mean(Image[:,:,0].ravel())
    mG=np.mean(Image[:,:,1].ravel())
    mB=np.mean(Image[:,:,2].ravel())
    #Computing the periodic component of each channel
    PR=np.abs(PeriodicComponent(Image[:,:,0]))
    PG=np.abs(PeriodicComponent(Image[:,:,1]))
    PB=np.abs(PeriodicComponent(Image[:,:,2]))
    #Generating a uniform template with the same mean value as the intial image
    Texture=np.ones([S0,S1,3])
    Texture[:,:,0]=Texture[:,:,0]*mR
    Texture[:,:,1]=Texture[:,:,1]*mG
    Texture[:,:,2]=Texture[:,:,2]*mB
    
    #Get center as integers since the division in Python 3 of two integers is not an integer 
    S02 = int(S0/2)
    M2 = int(M/2)
    S12 = int(S1/2)
    N2 = int(N/2)
    
    #Placing the periodic component at the center, the periodic component as its variance normalized
    Texture[(S02-M2):(S02-M2+M),(S12-N2):(S12-N2+N),0]=(PR-mR*np.ones([M,N]))*np.sqrt(S0*S1/(M*N))+mR*np.ones([M,N])
    Texture[(S02-M2):(S02-M2+M),(S12-N2):(S12-N2+N),1]=(PG-mG*np.ones([M,N]))*np.sqrt(S0*S1/(M*N))+mG*np.ones([M,N])
    Texture[(S02-M2):(S02-M2+M),(S12-N2):(S12-N2+N),2]=(PB-mB*np.ones([M,N]))*np.sqrt(S0*S1/(M*N))+mB*np.ones([M,N])
    #Classic RPN applied to the big image with the patch at the center
    R=RPN(Texture)
    #Saturation in case the Fourier's transform mapped to out of [0,1]
    #R[R<0]=0
    #R[R>1]=0.99999
    R = cv2.normalize(R, None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_8U)
    return R

def SaveImageFromNumpy(np_image,path="filename.jpeg"):
  im = Image.fromarray(np_image)
  im.save(path)